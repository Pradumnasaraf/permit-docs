---
sidebar_position: 5
title: SaaS and B2C Applications
---

import TimelineStep from "../../src/components/timeline/TimelineStep";
import TimelineWrapper from "../../src/components/timeline/TimelineWrapper";

Fine-grained authorization is crucial in consumer applications. In B2B systems, a few predefined roles can manage access. However, in B2C or SAAS platforms, both users, data, and required permissions grow rapidly. The need for precise permission control becomes indispensable. Additionally, self-service sign-ups in consumer apps demand a seamless experience for managing permissions. Users need to effortlessly control their access and also delegate permissions to others.

In this guide, we'll use a food ordering system to demonstrate how to combine RBAC, ABAC, and ReBAC to build a robust, fine-grained authorization model. With minimal code, we'll leverage Permit’s policy editor, SDKs, and APIs to implement flexible and scalable access control.

## Food Delivery System

Fast Food is becoming increasingly available globally. Services like Uber Eats, Jumia Food, DoorDash, among others, now deliver cooked food to people’s doorsteps. What does it take to build a similar food delivery service (FDS)?

You need different interfaces and permissions for different user types. For each user type, these interfaces will ordinarily be various mobile apps or websites. Notwithstanding, for a proof of concept, we will use a basic website.

The Food Delivery System (FDS) of this guide is built with [Nuxt](https://nuxt.com) / [Vue](https://vuejs.org). It has 4-pages one for each user type: `vendor`, `customer`, `admin`, and `rider`. We will look at its features, overall architecture, and most importantly, authorization policies.

## FDS Core Features

### 1. Meal Management

FDS is all about meals. Vendors (and admins) can create and delete meals. Every other person can see meals. Though meals are core to the service, they are not a heavy focus of permissions. We combine meals into orders and track them across the app.

### 2. Order Management

An order has different meals. It is a unit of delivery. When a customer adds meals to their cart and places an order, the vendor can prepare (or fulfill) it, the admin can assign a rider for it, and the rider can deliver it to the customer.

For this demo, the food delivery service shows these actions as buttons and records their occurrence times. However, for every action, we check if the acting user has the right permissions. We use defined policies to ensure allow or deny access to the acting user.

Of course, there is no real money in the context of orders here, it's just feature demos.

### 3. Composite Permissions

As we will see later, we combine separate authorization models (RBAC, ABAC, and ReBAC), where possible, for the same action. Primarily, we use the user’s type (or role) to allow for a range of actions on meals or orders. But instead of relying on just the user’s role, we check if they meet some conditions or have been linked to the target entity before allowing permissions.

For example, a user needs the `rider` role to make a delivery. On top of the `rider` role, if the involved order is for a promotional activity, we also check the rider’s number of rides before allowing them to deliver. Furthermore, we are only allowing riders to deliver rides assigned to them.

From the above, it is not enough to be a rider to make a delivery. Sometimes, the rider needs a “relationship” with the order. Other times, they also need to meet other conditions (based on their attributes).

### 4. Multitenant Authorization

At the authorization layer, multitenancy is built into the food delivery service with [Permit.io](http://Permit.io). In the FDS, tenants represent cities. The two cities (tenants) for FDS are `california` and `washington`. Using cities here is like simulating the food ordering system to be simultaneously working in multiple cities.

For authorization, permissions granted to a user for a specific action in `california` is not auto-granted in `washington`. This is what makes multitenancy an essential feature. That is, the ability to isolate policy application. You can assign roles, and add attributes and relationships in the context of a given tenant, without trespassing to the other.

### 5. Continuous Data-Syncing

FDS keeps on updating Permit with changes in data as they happen in real time. When a customer creates a new order, we record it with Permit. When we delete orders (when they get too much), we also record the deletion in Permit. Syncing data this way allows our authorization provider (Permit.io) to enforce policies as we expect efficiently.

## Server Endpoints

The FDS is a [Nuxt](https://nuxt.com) / [Vue](https://vuejs.org) app with a properly integrated frontend and server. The Vue frontend displays the meals and the orders and UI controls for them. The Nuxt server exposes endpoints for meal, order, and user management. It also handles authorization and enforces policies with Permit in proper server middleware.

Following are the API endpoints (and their functions) of the server:

| Method | Endpoint                  | Function                                                                | Authorization       |
| ------ | ------------------------- | ----------------------------------------------------------------------- | ------------------- |
| GET    | `/meals`                  | Retrieves all meals.                                                    | RBAC                |
| POST   | `/meals`                  | Creates a new meal.                                                     | RBAC                |
| DELETE | `/meal/:id/remove`        | Removes the meal with matching `id`.                                    | RBAC                |
| GET    | `/orders`                 | Retrieves all orders.                                                   | RBAC                |
| POST   | `/orders`                 | Creates a new order.                                                    | RBAC & ABAC         |
| POST   | `/order/:id/fulfill`      | Marks an order as ready.                                                | RBAC & ReBAC        |
| POST   | `/order/:id/assign-rider` | Attaches a rider to an order.                                           | RBAC                |
| POST   | `/order/:id/deliver`      | Marks an order as delivered to customer.                                | RBAC, ABAC, & ReBAC |
| POST   | `/users`                  | Creates/Updates a user with a role, adds attributes, & unassigns roles. | -                   |
| DELETE | `/users`                  | Removes a user from the Permit project.                                 | -                   |

All the endpoints above have middleware permission checks in them. These checks combine policies (RBAC, ABAC, or ReBAC) for fine-grained authorization. Doing this keeps unwanted actors away.

The exception is with the `/users` endpoints. They are not regulated with middleware. This allows you to grant and revoke roles and test flows in the FDS as much as you wish.

## Prerequisites, Setup, and Configuration

Before diving into the implementation, you'll need to set up your environment and ensure all dependencies are in place. Let's look at the necessary requirements and configuring everything to smoothly get started.

### a. Follow-Up Requirements

The code for this Food Delivery Service is at [https://github.com/permitio/permit-nuxt-example/tree/all-features](https://github.com/permitio/permit-nuxt-example/tree/all-features). Specifically, the complete setup with multitenancy, data sync, RBAC, ABAC, and ReBAC, are in the `all-features` branch.

Before setting up and configuring FDS to see it in action, you need to have the following in place:

#### 1. A [Permit.io](http://Permit.io) Project

FDS uses Permit as an Authorization solution. Use an existing project or create a new one at [https://app.permit.io](https://app.permit.io). You will obtain a Permit token for the Permit project to use in the code.

#### 2. Docker

You need a valid Docker installation to test “allow”s and “deny”s. We use [Docker](https://www.docker.com/) to run the [Policy Decision Point (PDP)](/concepts/pdp) for Nuxt / Vue Permissions.

#### 3. NodeJS

Nuxt and Vue are primarily JavaScript frameworks that work with [NodeJS](https://nodejs.org/). To continue, you need a working Node configuration.

### b. Setup and Configuration

Following are the steps to get you started with testing authorization with the food delivery app.

<TimelineWrapper>
<TimelineStep>

#### Clone the Repository

```bash
git clone https://github.com/permitio/permit-nuxt-example.git
cd permit-nuxt-example
git checkout all-features
```

</TimelineStep>
<TimelineStep>

#### Install Dependencies

```bash
npm install
```

</TimelineStep>
<TimelineStep>

#### Provide Environment Variables

- Obtain a Permit token from the [project settings in the Permit Console](https://app.permit.io/settings/api-keys).
- Create a `.env` file at the root of the project with the following. Put the copied token instead of the placeholder value.

```bash
PERMIT_TOKEN=permit_key_XXXXXXXXXXXXXXXXXXXXXXXXX
PERMIT_PDP=http://localhost:7766
```

</TimelineStep>
<TimelineStep>

#### Start a Local PDP

Run the following command to start up a local PDP. Also, put your permit token in the slated place.

```bash
  docker run -it \
    -p 7766:7000 \
    --env PDP_API_KEY=your-permit-api-key \
    --env PDP_DEBUG=True \
    permitio/pdp-v2:latest
```

</TimelineStep>
<TimelineStep>

#### Run the Development Server

```bash
npm run dev
```

</TimelineStep>
<TimelineStep>

#### Access the App

Open http://localhost:3000 in your browser. You will see the FDS app with its navigation for each page. Every action you take will not be authorized. You have to configure the necessary policies in the Permit UI. Remember to create, delete, assign, or unassign roles to test user IDs from the app. Also, review the Nuxt / Vue code to see what’s going on overall.

![FDS App View](/img/modeling/fds-nuxt/app-view.png)

</TimelineStep>
<TimelineStep>

#### Configure Authorization Policies

Setting up policies involves creating resources, actions on them, top-level roles, user and resource sets, and instance roles. On top of that, we need to use the Permit.io policy editor to allow permissions for desired app behavior. Each of the following sections highlights on how to define authorization policies.

</TimelineStep>
</TimelineWrapper>

## Configure Basic RBAC

Role-Based Access Control (RBAC) is usually the first line of authorization strategy to implement. FDS uses RBAC first for all actions. In the context of resources, we enforce the following policies.

**For Meals:**

- All roles (`customer`, `vendor`, `rider`, and `admin`) can view (_read_) meals.
- Only `vendor`s and `admin`s can _create_, _update_, and _delete_ meals.

**For Orders:**

- All roles can view orders.
- Only `customer`s can _create_ them.
- Only `vendor`s can _fulfill_ them (marking the orders as ready to be delivered).
- Only `admin`s can _assign riders_ to orders.
- Only `rider`s can _deliver_ them.
- `admin`s can also _create, fulfill,_ and _deliver_ orders.

To enforce the above RBAC policies,

<TimelineWrapper>
<TimelineStep>

In the Resources tab of the policy section of the Permit UI, create the "Meal" and "Order" resources with their involved actions.

</TimelineStep>
<TimelineStep>

In the Roles tab, create the 4 roles.

![Creating RBAC Resources](/img/modeling/fds-nuxt/rbac-creating-resources.gif)

</TimelineStep>
<TimelineStep>

In the policy editor, grant the appropriate permission for each role. When you refresh and test the running app, you can now carry out some actions.

![Viewing RBAC Policies](/img/modeling/fds-nuxt/rbac-viewing-policies.gif)

</TimelineStep>
</TimelineWrapper>

## Configure ABAC

Attribute-Based Access Control (ABAC) makes permissions more granular and fine-grained. In ABAC, we check for specific condition sets on user and/or resource attributes before allowing or denying permissions. When using ABAC, you group the attributes into conditions and create a set. So you can have multiple user sets and/or resource sets.

The FDS app uses promotional offers to show how to use ABAC. Orders with at least 500 costs are eligible for free delivery. Also, only riders with at least 500 number of rides can deliver these promotional orders. We can rephrase these ABAC policies as follows:

- A `customer` can _create a free delivery_ order **if** the order’s cost is greater than or equal to 500.
- A `rider` can _deliver_ a free delivery order **if** the rider’s number of rides is greater than or equal to 500.

Notice how these ABAC policies are built on top of the pre-defined RBAC ones. The ABAC policies use the roles and actions but add conditions to allow permissions.

To see this in action,

<TimelineWrapper>
<TimelineStep>

Edit the "Order" resource to

a. Create the `cost` attribute in it, and

b. Add a _create-with-free-delivery_ action in it.

</TimelineStep>
<TimelineStep>

Create the resource set for the ABAC condition.

![ABAC Resource Set](/img/modeling/fds-nuxt/abac-resource-set.gif)

</TimelineStep>
<TimelineStep>

[In the tenant settings](https://app.permit.io/user-management/tenant-settings/user-attributes), also create the `number_of_rides` attribute on users.

</TimelineStep>
<TimelineStep>

Create the respective user set for the ABAC conditions.

![ABAC User Set](/img/modeling/fds-nuxt/abac-user-set.gif)

</TimelineStep>
<TimelineStep>

In the policy editor, grant permissions for actions and test “allow”s in the running app.

![Policy Table for ABAC](/img/modeling/fds-nuxt/abac-policy-table.gif)

</TimelineStep>
</TimelineWrapper>

## Configure ReBAC

Relationship-Based Access Control (ReBAC) uses associations or links between users and resources to grant or deny permissions. ReBAC leverages relationships in the overall system for access control. The FDS application uses ReBAC to enforce the following policies:

- A `vendor` can only _fulfill_ an order **if** the vendor created the meals in that order.
- A `rider` can only _deliver_ an order **if** that order was assigned to the rider by the admin.

Order fulfillment by vendors uses two policy checks: the `vendor` role first and then the relationship of meals. Interestingly, order delivery uses all three authorization strategies. A user needs the `rider` role, the number of rides to exceed a minimum, and a relationship with the order before the rider can deliver the order.

ABAC and ReBAC usually extend RBAC and not replace it. These advanced authorization policies are really useful for introducing dynamic authorization flows as we’ve seen above.

To see ReBAC in action with FDS,

<TimelineWrapper>
<TimelineStep>

Create `Vendor` and `Rider` instance roles on the “Order” resource.

</TimelineStep>
<TimelineStep>

Update the policy editor to allow “fulfill” and “deliver” actions for these new roles on orders. Refresh the app and test extensively.

![Order#Vendor Instance Role and fulfill action in Policy Table](/img/modeling/fds-nuxt/rebac-vendor.gif)

</TimelineStep>
</TimelineWrapper>

## Syncing App Data

When you've planned authorization and setup policies, how do you ensure that they are applied to new users and resources? How do you impose permissions at all times in applications?

The solution is to continuously synchronize app data. When you sync, you make sure that newly created users and resources receive the same permissions as old ones. You also optimize your Permit project when you remove stale data.

Sync only data that is relevant for authorization. App users and resources could have plentiful properties in the app. But when syncing, only provide those that are involved in permissions. Also, the right time to sync is at any time data changes. In other words, sync when you there is data creation, modification, or deletion.

Permit SDKs provide several methods for programmatic synchronization. In Nuxt, you can use methods on `permit.api` to sync data as needed. For users, can create or update them with the `permit.api.users.sync` method in the same call.
The delete method is also available.

FDS syncs users with the Permit project in the handlers of the `/users` endpoints as follows:

```ts
// For creating / updating user
permit.api.users.sync({
  key: userId,
  attributes: { no_of_rides: noOfRides },
});

// For deleting a user
permit.api.users.delete(userId);
```

In addition to users, you can also sync resources and role assignments. You can:

- Use `permit.api.resources` methods for top-level resource management,
- Use `permit.api.resourceInstances` methods for managing specific instances of resources, or
- Use `permit.api.roleAssignments` methods for handling roles at both top-level (for RBAC) and at instance-level (for ReBAC).

These methods are multitenant-aware. If you are building with multitenancy, provide the tenant of context. Otherwise, set `"default"` as the tenant. Permit also let's you sync several other authorization related entities like user sets, resource sets, conditions, among others.

In the FDS code, we are syncing orders with the Permit project. We also assign the related instance role on the "Order" resource where appropriate.

```ts
// Sync a new order with Permit
permit.api.resourceInstances.create({
  key: id,
  resource: "Order",
  attributes: { cost: totalPrice },
  tenant: "california",
});

// Set the Order's Vendor with Permit
permit.api.roleAssignments.assign({
  user: vendor,
  role: "Vendor",
  resource_instance: `Order:${id}`,
  tenant: "california",
});

// Sync a deleted order with Permit
permit.api.resourceInstances.delete(`Order:${id}`);
```

## Enforce Permissions

Enforcing permissions is making sure that authorization policies always get applied. You usually do these enforcements as a gate-keeping mechanism. Think of a lock for system resources that whose key is the policy. In our context, you open the key by **checking** for permissions.

You can check permissions in server middleware and in UI parts. In middleware, you use `permit.check` function that is available in all Permit's SDKs. In frontend code, you use [CASL](/integrations/feature-flagging/casl) together with Permit.

The `permit.check` takes a user, an action, and a resource. It works for all policies that are involved between its 3 arguments. It dynamically uses everything defined in the policy editor for to either return `true` or `false` (whether permitted or not).

When checking, provide the user, action, and resource in the context of your app's features. Also provide tenants when dealing with multitenancy or ReBAC policies.

In the FDS, we use Permit checks in middleware for RBAC, ABAC, and ReBAC policies auto-combined. For example, the `permit.check` call for permitting a rider to deliver is as follows:

```ts
const canRiderDeliver = await permit.check(
  userId, // user 
  "deliver", // action
  { type: "Order", key: orderId, tenant: "california" }, // resource
);

// Prevent the rider from doing the delivery if not authorised
if (!canRiderDeliver) {
  return {
    success: false,
    message: "You are not permitted to perform this action",
  };
}
```

You should use the result of the check function to either allow or deny access for the target action. In the example above, we simply reject the HTTP call we an appropriate message.

In the Vue frontend, you can bulk load permissions for a given user and toggle parts of the UI based on permissions or "abilities". Though not used directly in this guide's repo, [you can find an example here](https://github.com/permitio/permit-vue-example/blob/casl/src/components/OrdersDisplay.vue).

```ts
<script setup lang="ts">
// ...

const fulfill = async (orderId: number) => {
  if (permit.value.check('fulfill', 'Order', {})) {
    // ...
  }
};

const assignRider = async (e: FormSubmitEvent, orderId: number) => {
  if (e.valid && permit.value.check('assign-rider', 'Order', {})) {
    // ...
  }
};

const deliver = async (orderId: number) => {
  if (permit.value.check('deliver', 'Order', {})) {
    // ...
  }
};
</script>

<template>
  <!-- ... --->

  <Button 
    label="Fulfill"
    v-if="!order.fulfilledTime && permit.check('fulfill', 'Order', {})"
    @click="fulfill(order.id)"
  />
  <Button 
    label="Deliver"
    v-if="!order.deliveredTime && permit.check('deliver', 'Order', {})"
    @click="deliver(order.id)"
  />
  <Form 
    @submit="(e) => assignRider(e, order.id)"
    v-if="
      permit.check('assign-rider', 'Order', {}) &&
      !order.riderAssignedTime
    "
    class="flex gap-4 items-end"
  >
    <!-- ... --->
  </Form>

  <!-- ... --->
</template>
```