---
sidebar_position: 3
title: ABAC & Feature Flagging - Custom User Experience
---

This tutorial will guide you through setting up **[ABAC](/how-to/build-policies/abac/overview)**
(Attribute-based Access Control) policies with Permit and show you how to create a custom user experience.
This depends on who's **logged in**, their **role**, and the specific rules (or **attributes**) set for
that role, making permissions more granular and specific.

The approach is useful in cases where you're adding new features to your system and want to make them
available only to a select group of test users. It’s also common to use this method when you have paying
customers, adjusting their app experience based on their status and even location, ensuring a tailored
and strategically guided user journey.

### What we will build

In this project, we'll create an app that displays specific tiles according to the user's role and the
permissions they have. The app will not only consider resources but also the attributes related to those
resources, ensuring a finely tuned enforcement of permissions.

The dashboard will dynamically load appropriate tiles, considering factors like the user's country and the
sales channel to which they belong.

### UI example with all permissions enabled

#### The UI

![All tiles](/ui-videos/modeling/custom-ui-demo/feature-flagging-1.png)

#### The Permit Policy

![All Permissions](/ui-videos/modeling/custom-ui-demo/feature-flagging-2.png)

### UI example with some permissions enabled

#### The UI

![One tile](/ui-videos/modeling/custom-ui-demo/feature-flagging-3.png)

#### The Permit Policy

![One Permission](/ui-videos/modeling/custom-ui-demo/feature-flagging-4.png)

## Prerequisites

Before embarking on this project, ensure you have the following prerequisites in place:

1. An account with Permit
2. A properly configured PDP (Policy Decision Point) with the correct API Key
3. The Permit SDK package installed
4. An authentication provider of your choosing (we support them all), and for this tutorial, we have used [clerk.com](https://clerk.com/)
5. A basic app where you'll enforce permissions and adjust the UI. For this demo, you can clone a
   `nextjs/react` boilerplate starter.

## Modeling basic roles and resources

As part of this project, we will be working with our `fe-permit-sdk` and CASL to build a feature toggling solution that uses Permit for managing who can view specific components in your application.

In this walkthrough, we will be using a more granular model for rendering components, called ABAC - or in other words, Attribute-based Access Control.
This will allow us to not just check against a role for the currently logged in user, but also against specific conditions, which
the policy engine will understand, and allow a far more granular access.

If you want to dive deeper into understanding ABAC, check out our guide [here](/how-to/build-policies/abac/overview).

The first step is to define the extra attributes we will be working with. In our example, we are working with an authentication provider
called `Clerk.com`. Clerk allows us to store some metadata for individual users. In this case, for each user, we are storing their
`country` and `channel`.

![Clerk Attributes](/ui-videos/modeling/custom-ui-demo/clerk-attributes.png)

The attributes defined in the authentication provider needs to be mapped into Permit. Permit needs to know their name, and what type of
data they are. In this case, both are a `String` - but many different data types are available for you to pick from.

![Clerk Attributes](/ui-videos/modeling/custom-ui-demo/attributes.png)

Once we define out attributes, we need to define the resources we will be working with. Each defined resource should be the UI
component that we want to conditionally render. Let's start off by defining the first resource.

![Clerk Attributes](/ui-videos/modeling/custom-ui-demo/new-resource.png)

Now, we can define all the four resources we want to work with.

![Clerk Attributes](/ui-videos/modeling/custom-ui-demo/all-resources.png)

Each resource will need corresponding attributes to be defined as part of it. We will be using the values of these resources for our
`loadLocalStateBulk` function, passing in the `resource`, `resource attributes` and `action`.

![Clerk Attributes](/ui-videos/modeling/custom-ui-demo/resources-with-attributes.png)

## Rendering UI based on permissions

The below guide is a swift implementation of what needs to be done to get CASL to render our components based
on this example project. If you want to go into more details about what CASL is and how it works, check out
our in-depth guide [here](/integrations/feature-flagging/casl).

Firstly we need to create a `Viewer` role. This role will have access to all the resources and therefore we will be able to define the
policy regarding which resource can be viewed, and which one cannot.

![Clerk Attributes](/ui-videos/modeling/custom-ui-demo/viewer-role.png)

Once we have our role in place, we can start to adjust the policy as we wish. Below is an example where we can only view one resource
called `Topics for you`.

![Clerk Attributes](/ui-videos/modeling/custom-ui-demo/viewer-role-policy-limited.png)

We also can adjust the policy to view all the components.

![Clerk Attributes](/ui-videos/modeling/custom-ui-demo/viewer-role-policy.png)

### Creating an API endpoint to handle permission checks

As part of the CASL component that we will be creating later in this guide, we will need to specify an API
route that we can call, which will perform bulk `permit.check()` operations for us, returning the result for
each.

Here is a basic implementation of such endpoint, which we have under `/api/something`. You can name the file
as you wish.

```js
import { Permit } from "permitio";

const permit = new Permit({
  token: "YOUR_PERMIT_API_KEY",
  pdp: "http://localhost:7766",
});

export default async function handler(req, res) {
  try {
    const { resourcesAndActions } = req.body;
    const { user: userId } = req.query;

    if (!userId) {
      return res.status(400).json({ error: "No userId provided." });
    }

    const checkPermissions = async (resourceAndAction) => {
      const { resource, action, userAttributes, resourceAttributes } = resourceAndAction;

      const allowed = permit.check(
        {
          key: userId,
          attributes: userAttributes,
        },
        action,
        {
          type: resource,
          attributes: resourceAttributes,
          tenant: "default",
        }
      );

      return allowed;
    };

    const permittedList = await Promise.all(resourcesAndActions.map(checkPermissions));

    console.log(permittedList); // Printing the result of the checks

    return res.status(200).json({ permittedList });
  } catch (error) {
    console.error(error);
    return res.status(500).json({ error: "Internal Server Error" });
  }
}
```

Pay attention that we have imported the Permit library and we initialized the Permit object. You can follow
this [guide](/overview/connecting-your-app#1-get-your-permit-environment-api-key) to understand where to fetch your API key from.

Once we are done with this step, we need to make sure pull and launch our PDP - you can also find the steps on
how to do this [here](/overview/connecting-your-app#2-setup-your-pdp-policy-decision-point-container).

### Creating the `AbilityLoader`

The AbilityLoader component is integral to this setup, diligently working to asynchronously retrieve and
establish user-specific permissions, particularly upon user sign-in.

In this scenario, we're employing Clerk.com as our authentication provider to obtain the userId, which we have
synchronized with Permit. This allows us to identify the currently logged-in user and correlate them with the
associated policy for their role. It's crucial to highlight that you can choose any authentication provider
that best fits your needs—Permit is designed to integrate seamlessly with all of them.

```js
import React, { createContext, useEffect, useState } from "react";
import { useUser } from "@clerk/nextjs";
import { Ability } from "@casl/ability";
import { Permit, permitState } from "permit-fe-sdk";

// Create Context
export const AbilityContext = createContext();

export const AbilityLoader = ({ children }) => {
  const { isSignedIn, user } = useUser();
  const [ability, setAbility] = useState(undefined);

  useEffect(() => {
    const getAbility = async (loggedInUser) => {
      const permit = Permit({
        loggedInUser: loggedInUser,
        backendUrl: "/api/something",
      });

      await permit.loadLocalStateBulk([
        {
          action: "view",
          resource: "Products",
          userAttributes: {
            country: "PL",
            channel: "ABC",
          },
        },
        {
          action: "view",
          resource: "Product_Configurators",
          userAttributes: {
            country: "UK",
            channel: "ABC",
          },
        },
        {
          action: "view",
          resource: "Project_Builder",
          userAttributes: {
            country: "FR",
            channel: "DEF",
          },
        },
        {
          action: "view",
          resource: "Topics_for_you",
          userAttributes: {
            country: "ES",
            channel: "DEF",
          },
        },
      ]);

      const caslConfig = permitState.getCaslJson();

      return caslConfig && caslConfig.length ? new Ability(caslConfig) : undefined;
    };

    if (isSignedIn) {
      getAbility(user.id).then((caslAbility) => {
        setAbility(caslAbility);
      });
    }
  }, [isSignedIn, user]);

  return <AbilityContext.Provider value={ability}>{children}</AbilityContext.Provider>;
};
```

### Conditionally rendering the UI

First of all, in the file where you want to render part of the UI based on a condition, make sure you import
`permitState`.

```js
import { permitState } from "permit-fe-sdk";
```

Then, utilize permitState to render parts of the HTML.

```js
<div className="flex h-full">
  <div className="flex flex-col flex-grow">
    {permitState?.check("view", "Products", {
      country: user.publicMetadata.country,
      channel: user.publicMetadata.channel,
    }) && <div className="bg-white m-4 p-4 h-[250px]">Products</div>}

    {permitState?.check("view", "Product_Configurators", {
      country: user.publicMetadata.country,
      channel: user.publicMetadata.channel,
    }) && <div className="bg-white m-4 p-4 h-[200px]">Product Configurators</div>}

    {permitState?.check("view", "Project_Builder", {
      country: user.publicMetadata.country,
      channel: user.publicMetadata.channel,
    }) && <div className="bg-white m-4 p-4 h-[200px]">Project Builder</div>}

    {permitState?.check("view", "Topics_for_you", {
      country: user.publicMetadata.country,
      channel: user.publicMetadata.channel,
    }) && <div className="bg-white m-4 p-4 h-[100px]">Topics for you</div>}
  </div>
</div>
```

And here you have it. A quick quite to implementing feature toggling in your frontend UI with the use of Permit to enforce who can
and cannot view the specific components!
