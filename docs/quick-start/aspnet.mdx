---
title: ASP.NET
sidebar_position: 9
---

Learn how to leverage the Permit API and SDK to seamlessly integrate robust access control into your ASP.NET application. This step-by-step guide walks you through setting up your environment, creating policies with the Permit CLI with minimal code and maximum flexibility.

import TimelineStep from "../../src/components/timeline/TimelineStep";
import TimelineWrapper from "../../src/components/timeline/TimelineWrapper";    

---

In this guide, we will quickly go through the steps to integrate Permit.io with ASP.NET. We will use Permit's CLI to create a new environment and a policy with a template. Then, we will use the Permit SDK to integrate it with our ASP.NET application. We will also set up the PDP (Policy Decision Point) server locally using Docker.

## Prerequisites

- ASP.NET application
- [Docker](https://www.docker.com/) (for running the PDP server)  
- [Node.js](https://nodejs.org/en) (for installing and running the Permit CLI)  
- [Permit.io](https://permit.io) account (Follow [this](/quickstart) guide to create an account)

<TimelineWrapper>
<TimelineStep>

### Installing the Permit CLI

We will first install the [Permit CLI](https://github.com/permitio/permit-cli). Permit CLI is a command-line tool that allows you to create policies, run the PDP server, and perform other tasks. To install the CLI, execute the command below in your terminal.

```bash
npm install -g @permitio/cli
```

Once the installation is complete, execute `permit` to confirm the installation. 

</TimelineStep>
<TimelineStep>

### Authenticating the CLI

To use the CLI, we need to authenticate it with our Permit account. To authenticate, execute 

```bash
permit login
```

This will open a browser window and ask you to log in with your Permit account. After logging in, the CLI will be authenticated and ready to use. This will also log you into the default environment (a project can have multiple environments). 

We can change the environment by executing `permit env select` and then selecting the environment we want to use.

</TimelineStep>
<TimelineStep>

### Creating a policy with a template

Permit CLI offers various templates to create a policy with predefined roles and resources using best practices. This will save us time and effort in creating a policy from scratch.

To check the available templates, execute `permit template list`. Also, you can head over to the [Permit CLI repo](https://github.com/permitio/permit-cli/tree/main/source/templates) to see the templates and the actual terraform code for each template.

![permit template list](/img/quick-start-guide/permit-template-list.png)

We will be using the **blogging-platform** template to create the policy. This template will help us setting up a policy for a blogging platform with roles and resources. The policy is explained in detail below in the next step.

To apply the template, execute the command below.

```bash
permit template apply --template blogging-platform
```

You will see a successful message in the terminal.

</TimelineStep>
<TimelineStep>

### Understanding and accessing the policy from the dashboard

Now, head over to the Permit's dashboard and select the project and click on the **Policy** tab from the left sidebar. You will see the policy we just created.

![permit policy](/img/quick-start-guide/policy-editor-dash.png)

This policy defines access control for a blogging platform, here is breakdown of the policy: 
- **Posts** and **Comments** are the resources.
- Users are assigned roles like **Author**, **Moderator**, or **Reader**, with permissions scoped to each resource.
- A `premium` attribute on posts enables ABAC, restricting access to premium content.
- Through a **Postâ€“Comment** relationship, **Post Authors** automatically become **Comment Moderators**.
- A **Free Post** resource set filters non-premium posts, allowing **Readers** to access only free content.
The setup combines ABAC and ReBAC to enforce flexible and secure permissions.

It's quite easy to add and remove the permissions by checking and unchecking the permissions in the policy editor.

</TimelineStep>
<TimelineStep>

### Getting the API key

To get the API key:

1. Click on **Projects** from the left sidebar.
2. Click on the three dots on the environment we want to use.
3. Click on **Copy API Key** and store it in a safe place. We will be using this API key to authenticate our application with Permit.io. If you are having any difficulty getting the API key, follow this [guide](/overview/connecting-your-app/#1-get-your-permit-environment-api-key).

Once we are done, let's move toward the implementation part and integrate Permit.io with our ASP.NET application.

</TimelineStep>
<TimelineStep>

### Setting up the ASP.NET application

Once you have your .NET application ready (or you can create a new one for the sake of this guide), we can start integrating the Permit's .NET SDK. To install the Permit SDK, execute the command below in your terminal.

```bash
dotnet add package Permit
```

Read more about the .NET SDK [here](/sdk/dotnet/quickstart-dotnet).

</TimelineStep>
<TimelineStep>

### Creating the endpoints

Once we have installed the SDK, let's create a namespaced class to put our logic.

```csharp
// Program.cs
using System;
using System.Text;
using System.Net;
using System.Threading.Tasks;
using System.IO;
using System.Text.Json;
using PermitSDK;
using PermitSDK.OpenAPI.Models;

namespace PermitOnboardingApp
{

    public class SyncUserRequest
    {
        public string email { get; set; }
        public string first_name { get; set; }
        public string last_name { get; set; }
    }

    public class CreateTenantRequest
    {
        public string key { get; set; }
        public string name { get; set; }
        public string description { get; set; }
    }

    public class CheckPermissionRequest
    {
        public string user { get; set; }
        public string action { get; set; }
        public string resource { get; set; }
    }
}
```

We have created namespace `PermitOnboardingApp` and inside it we have created three classes: `SyncUserRequest`, `CreateTenantRequest`, and `CheckPermissionRequest`. These classes are used to deserialize the request body for each endpoint.

</TimelineStep>
<TimelineStep>

### Creating the endpoints

Inside the namespace, we have created a class `HttpServer` that will handle the incoming requests.

```csharp
    class HttpServer
    {
        public static HttpListener listener;
        public static string url = "http://localhost:8000/";
        public static string clientToken = Environment.GetEnvironmentVariable("PERMIT_API_KEY");
        public static string pdpUrl = Environment.GetEnvironmentVariable("PDP_URL");

        public static Permit permit = new Permit(
            clientToken,
            pdpUrl,
            "default",
            true
        );

        public static async Task HandleSyncUser(HttpListenerRequest req, HttpListenerResponse resp)
        {
            using var reader = new StreamReader(req.InputStream, req.ContentEncoding);
            var body = await reader.ReadToEndAsync();
            var data = JsonSerializer.Deserialize<SyncUserRequest>(body);
            if (data == null || string.IsNullOrEmpty(data.email) || string.IsNullOrEmpty(data.first_name) || string.IsNullOrEmpty(data.last_name))
            {
                resp.StatusCode = 400;
                await SendJsonAsync(resp, new { error = "Missing required fields" });
                return;
            }
            var userObj = new UserCreate
            {
                Key = data.email,
                Email = data.email,
                First_name = data.first_name,
                Last_name = data.last_name,
                Attributes = new System.Collections.Generic.Dictionary<string, object>()
            };
            var user = await permit.Api.SyncUser(userObj);
            resp.StatusCode = 201;
            await SendJsonAsync(resp, user);
        }

        public static async Task HandleCreateTenant(HttpListenerRequest req, HttpListenerResponse resp)
        {
            using var reader = new StreamReader(req.InputStream, req.ContentEncoding);
            var body = await reader.ReadToEndAsync();
            var data = JsonSerializer.Deserialize<CreateTenantRequest>(body);
            if (data == null || string.IsNullOrEmpty(data.key) || string.IsNullOrEmpty(data.name))
            {
                resp.StatusCode = 400;
                await SendJsonAsync(resp, new { error = "Missing required fields" });
                return;
            }
            var tenantObj = new TenantCreate
            {
                Key = data.key,
                Name = data.name,
                Description = data.description,
                Attributes = new System.Collections.Generic.Dictionary<string, object>()
            };
            var tenant = await permit.Api.CreateTenant(tenantObj);
            resp.StatusCode = 201;
            await SendJsonAsync(resp, tenant);
        }

        public static async Task HandleCheckPermission(HttpListenerRequest req, HttpListenerResponse resp)
        {
            using var reader = new StreamReader(req.InputStream, req.ContentEncoding);
            var body = await reader.ReadToEndAsync();
            var data = JsonSerializer.Deserialize<CheckPermissionRequest>(body);
            if (data == null || string.IsNullOrEmpty(data.user) || string.IsNullOrEmpty(data.action) || string.IsNullOrEmpty(data.resource))
            {
                resp.StatusCode = 400;
                await SendJsonAsync(resp, new { error = "Missing required fields" });
                return;
            }
            bool permitted = await permit.Check(data.user, data.action, data.resource);
            resp.StatusCode = permitted ? 200 : 403;
            await SendJsonAsync(resp, new { message = permitted ? "User is permitted" : "User is not permitted" });
        }
    }
```

First, we have created a static `Permit` object that will be used to interact with the Permit API. It needs two environment variables `PERMIT_API_KEY` is the API key we copied from the Permit dashboard, and the `PDP_URL` is the URL of the PDP server. We will set this up later.

We have created three methods to handle the incoming requests:
- `HandleSyncUser`: Handles the `/sync-user` endpoint. That will sync a user with Permit.io.
- `HandleCreateTenant`: Handles the `/create-tenant` endpoint. That will create a tenant with Permit.io.
- `HandleCheckPermission`: Handles the `/check-permission` endpoint. That will check if the user has access to the resource.

</TimelineStep>
<TimelineStep>

### Creating the helper methods and the main method

Let's create a helper method and the main method inside the `HttpServer` class.

```csharp
        public static async Task SendJsonAsync(HttpListenerResponse resp, object obj)
        {
            resp.ContentType = "application/json";
            var json = JsonSerializer.Serialize(obj);
            var buffer = Encoding.UTF8.GetBytes(json);
            await resp.OutputStream.WriteAsync(buffer, 0, buffer.Length);
            resp.Close();
        }

        public static async Task HandleIncomingConnections()
        {
            while (true)
            {
                var ctx = await listener.GetContextAsync();
                var req = ctx.Request;
                var resp = ctx.Response;

                if (req.HttpMethod == "POST" && req.Url.AbsolutePath == "/sync-user")
                    await HandleSyncUser(req, resp);
                else if (req.HttpMethod == "POST" && req.Url.AbsolutePath == "/create-tenant")
                    await HandleCreateTenant(req, resp);
                else if (req.HttpMethod == "POST" && req.Url.AbsolutePath == "/check-permission")
                    await HandleCheckPermission(req, resp);
                else
                {
                    resp.StatusCode = 404;
                    await SendJsonAsync(resp, new { error = "Not found" });
                }
            }
        }

        static void Main(string[] args)
        {
            listener = new HttpListener();
            listener.Prefixes.Add(url);
            listener.Start();
            Console.WriteLine($"Listening for connections on {url}");
            Task listenTask = HandleIncomingConnections();
            listenTask.GetAwaiter().GetResult();
            listener.Close();
        }
```

- `SendJsonAsync`: Sends a JSON response back to the client. It will be used to send the response to the client.
- `HandleIncomingConnections`: Handles the incoming requests and calls the appropriate method based on the request URL. It will be used to handle the incoming requests.
- `Main`: Starts the HTTP server and listens for incoming requests. It will be used to start the HTTP server and listen for incoming requests.

</TimelineStep>
<TimelineStep>

### Setting up the PDP server

Now, our application is ready by syncing the user and having a policy created. Let's enforce and check the policy. To enforce the policy, we use [Permit's PDP](/concepts/pdp/overview) (Policy Decision Point) to check if the user has access to the resource. So first, let's set up the PDP.

By running the following command, Permit CLI will spin up our environment PDP in a docker container.

```bash
permit pdp run
```

Once we execute the above command, you will see an output like the one below, with information such as container ID, name, etc.

![permit pdp run](/img/quick-start-guide/create-pdp.png)

The PDP server will be running on port `7766` by default. We can also change the port. Finally, update the `PDP_URL` environment variable in your application.

</TimelineStep>
<TimelineStep>

### Syncing the user

Now we have everything ready. Let's run the application and use `curl` requests to test the endpoint for the sync user route.

![curl create user](/img/quick-start-guide/dotnet-sync-user.png)

As we can see in the image above, the user is created successfully, and we get a lot of information about the user in the response, such as `id`, `project_id`, `key`, etc.

</TimelineStep>
<TimelineStep>

### Giving the user access to the resource

Now that we have created a user, let's give this user access to the resource we created in the policy. To do that:
1. Select **Directory** from the left sidebar in Permit's dashboard.
2. Click **Add Role** button.
3. Select tenant **(default)** from the dropdown.
4. Select the **Author** role and save it.

We will verify this later when we check the access.

![user access](/img/quick-start-guide/user-access.png)

We can also add more roles and resources as per our needs. Now, let's set up the PDP server and check the access.

:::info
We can give the access programmatically, it was a demo to show how easy it is to add access using the dashboard.
:::

</TimelineStep>
<TimelineStep>

### Checking the access

Now, let's check the policy enforcement. As we have added the user to the **Author** role, we can check if the user has **create** access to the **Post** resource. To do that, we will use the `curl` command to make a request to the `/check-permission` endpoint.

![curl check access](/img/quick-start-guide/dotnet-user-permitted.png)

As we can see in the image above, the user is permitted to access the resource. Let's remove the access from the dashboard and check again.

![curl check access](/img/quick-start-guide/dotnet-user-not-permitted.png)

Now, this time, we can see that the user is not permitted to access the resource. This is how we can enforce policies using Permit.io with ASP.NET.

</TimelineStep>
</TimelineWrapper>

### Conclusion

In this guide, we have seen how to integrate Permit.io with ASP.NET. We have created a new policy with a template using the Permit CLI. Then we have integrated the Permit SDK with our ASP.NET application. We have also set up the PDP server locally using Docker.

## Further Reading

- [Learn how you can do Frontend Authorization with CASL](/integrations/feature-flagging/casl)
- [Manage your Policy Life Cycle - Ci/CD](/how-to/SDLC/CI-CD)
- [GitOps and Custom Polices (PBAC)](/integrations/gitops/overview)
